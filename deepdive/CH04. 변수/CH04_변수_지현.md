#1 # 4장 변수

## 4.1 변수

- 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
    - 메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류 가능성↑
    - 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘, 값의 위치를 가리키는 상징적인 이름
- 변수 이름(변수명) : 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름
- 변수 값 : 변수에 저장된 값
    - 할당(대입, 저장) : 변수에 값을 저장하는 것
    - 참조 : 변수에 저장된 값을 읽어 들이는 것

## 4.2 식별자

- 어떤 값을 구별해서 식별할 수 있는 고유한 이름
    - 어떤 값이 저장되어 있는 메모리 주소를 기억(저장)해야 함
    - 값이 저장되어 있는 메모리 주소와 매핑관계, 이 매핑정보도 메모리에 저장되어야 함
    - 값이 아니라 메모리 주소 기억
    - 메모리 주소에 붙인 이름
    - 변수, 함수, 클래스 등의 이름은 모두 식별자
    - 네이밍 규칙 준수, 선언에 의해 존재를 알림

## 4.3 변수 선언

- 변수를 생성하는 것
    - 값을 저장하기 위한 메모리 공간을 확보
    - 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비
    - 선언에 의해 확보된 메모리 공간은 해제되기 전까지는 보호
- 변수를 사용하려면 반드시 선언이 필요
    - var, let, const 키워드 사용
- 변수를 선언한 이후 변수에 값을 할당하지 않았을 때
    - 확보된 메모리 공간에는 자바스크립트 엔진에 의해 undefined라는 값이 암묵적으로 할당되어 초기화
- 변수 이름은 어디에 등록되는가?
    - 모든 식별자는 실행 컨텍스트에 등록
    - 실행 컨텍스트 : 소스코드를 평가하고 실행하기 위해 필요한 환경 제공 및 코드의 실행결과를 실제로 관리하는 영역
    - 변수 이름과 변수값은 실행컨텍스트 내에 키/값 형식인 객체로 등록되어 관리
- var 키워드를 사용한 변수선언은 선언 단계와 초기화 단계가 동시 진행
    - 초기화 : 변수가 선언된 이후 최초로 값을 할당하는 것
    - var 키워드 선언한 변수는 undefined로 초기화 자동 수행
    - 초기화단계 거치지 않을 경우 쓰레기 값 존재 가능성有 → var 키워드는 해당無

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

- 변수 선언이 소스코드가 한 줄씩 순차적으로 시행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행
- 소스코드의 평가 과정을 거치면서 실행하기 위한 준비를 함
    - 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행
    - 위 과정이 끝난 후 선언문을 제외하고 한 줄씩 순차적 실행
    - 변수 선언이 어디에 있든 상관없이 다른 코드보다 먼저 실행
    - 위치에 상관없이 어디서든지 변수 참조 가능
- 변수 호이스팅 : 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
    - 모든 식별자(변수, 함수, 클래스 등)는 호이스팅 됨

## 4.5 값의 할당

- 할당 연산자 =를 사용
- 우변의 값을 좌변의 변수에 할당
    - 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 2개의 문으로 나누어 각각 실행
    - 주의! 변수 선언과 값의 할당 실행 시점이 다름
        - 변수 선언 : 런타임 이전
        - 값의 할당 : 런타임 실행
- 변수에 값을 할당할 때는 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값 80을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값 80을 저장!

## 4.6 값의 재할당

- 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당
- var 키워드로 선언한 변수는 값을 재할당 가능
- 상수 : 값을 재할당할 수 없음. 한번 정해지면 변하지 않는 값. 단 한 번만 할당할 수 있는 변수
- const 키워드로 선언한 변수는 재할당 금지. 상수 표현 가능
    - 반드시 상수만을 위해 사용하지는 않음.
- 어떤 식별자와도 연결되어 있지 않은 변수의 이전값들은 가비지 콜렉터에 의해 자동 해제
    - 단, 메모리에서 언제 해제될지는 예측불가
    - 가비지콜렉터 : 애플리케이션이 할당한 메모리 공간을 주기적으로 검사, 사용되지 않는 메모리 해제하는 기능, 메모리 누수 방지
        - 언매니지드 언어 : C언어 ( 개발자가 메모리 할당, 해제하기 위해 malloc()과 free() 같은 저수준 메모리 제어기능 제공 ) , 메모리 제어를 개발자가 주도→ 개발자 역량에 따라 최적의 성능 확보 가능성有 , 반대의 경우 치명적 오류 생산
        - 매니지드 언어 : 개발자의 직접적인 메모리 제어 허용하지 않음. 명시적으로 메모리 할당, 해제 불가. 가비지 콜렉터가 수행하고 이 또한 개발자 관여 불가. 일정한 생산성을 확보할 수 있으나 성능 면에서 손실은 감수할 수밖에 없음

## 4.6 식별자 네이밍 규칙

- 특수문자 제외한 문자, 숫자, 언더스코어(_), 달러 기호($) 포함 가능
- 숫자로 시작하는 것은 불가
- 예약어 사용 불가
- 자바스크립트는 대소문자 구별
- 네이밍 컨벤션 : 하나 이상의 영어 단어로 구성된 식별자 만들 때 규정한 명명 규칙
    - 카멜 케이스 : var firstName;
    - 스네이크 케이스 : var first_name;
    - 파스칼 케이스 : var FirstName;
    - 헝가리언 케이스
        - var strFirstName; // type + identifier
        - var $elem = document.getElementById(’myId’); // DOM노드
        - var observable$ = fromEvent(document, ‘click’); // RxJS 옵저버블
- 자바스크립트에서는 일반적으로
    - 변수나 함수 이름은 카멜케이스
    - 생성자 함수, 클래스 이름은 파스칼 케이스
