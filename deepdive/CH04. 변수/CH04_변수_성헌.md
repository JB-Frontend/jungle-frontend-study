# 1. 변수

<aside>
💡 변수는 **하나의 값을 저장하기 위해 확보한 메모리 공간 자체** 또는 그 **메모리 공간을 식별하기 위해 붙인 이름**을 말한다. 즉, 간단히 말하자면 값의 위치를 가리키는 상징적인 이름이라고 할 수 있다.

</aside>

### Keywords

---

- `변수명 == 식별자`, 값이 저장되는 메모리의 주소와 매핑 관계를 맺고 매핑 정보도 메모리에 함께 저장된다. 즉 식별자는 값을 기억하는 것이 아니라 값이 저장된 메모리의 주소를 기억하는 것이다.
- 변수 선언은 선언 단계, 초기화 단계의 2가지 단계로 이루어져 있다. var 키워드로 선언한 변수는 동시에 let 이나 const 로 선언한 변수는 따로 진행된다.
- let 으로 선언된 변수는 선언 단계와 초기화 단계가 따로 진행되며 호이스팅은 일어나지만 초기화 단계는 변수 선언문에 도달했을 때 실행되기 때문에 변수 선언문 이전(초기화 단계가 실행되기 이전)에 변수에 접근하려고 하면 참조 에러가 발생한다.
- 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지 변수를 참조할 수 없는 구간을 일시적 사각지대(**TDZ : Temperal Dead Zone**)라고 한다.
- 호이스팅이란 변수 선언문이 코드의 최상단에 끌어올려진 것처럼 동작하는 것을 말한다. (코드가 실행되는 시점인 런타임 이전에 실행된다.)

### 변수

---

- **변수명** (= 변수 이름, 식별자) : 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름.
    - 변수명은 변수에  저장된 값의 의미를 파악할 수 있는 중요한 수단이다. 그러므로 변수명을 지을 때는 신중하게 심사숙고해서 지어야한다.
    - 변수명을 **식별자**라고도 하며, 식별자란 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.
    - 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해낼 수 있어야 한다. **즉, 식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장**되어야 한다. (식별자는 값이 아니라 메모리 주소를 기억하고 있다.)
    - 식별자는 네이밍 규칙을 준수해야 하며, **선언**에 의해 JS 엔진에 식별자의 존재를 알린다.
- **변수값** : 변수에 저장된 값.
- **할당** : 변수에 값을 저장하는 것.
- **참조** :  변수에 저장된 값을 읽어 들이는 것.

## 변수 선언 (declaration)

<aside>
💡 변수를 사용하려면 반드시 선언이 필요하며, 선언할 때는 var, let, const 키워드를 사용한다.

</aside>

### 변수 선언 순서

---

1. **선언 단계** : 변수 이름을 등록해서 JS 엔진에 변수의 존재를 알린다.
2. **초기화 단계** : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화한다. (일반적으로 초기화란 변수가 선언된 이후 최초로 값을 할당하는 것을 의미한다.)
    
    > **초기화 단계를 거치는 이유?** 확보된 메모리 공간에 이전에 사용했던 값이 남아있을 수 있음. 이러한 값을 쓰레기 값이라고 함.
    > 
3. **할당 단계 :** 값이 저장된다.

### 변수 선언 키워드

---

- **var**
    - `var` 키워드를 이용해서 변수를 선언하면, 값을 할당하지 않아도 암묵적으로 `undefined`라는 값이 할당되어 초기화 된다. 즉 `undefined`**로 암묵적인 초기화**가 자동 수행된다.
    - 선언되지 않은 식별자에 접근하면 ReferenceError(참조 에러) 가 발생한다.
    - `var` 키워드를 이용해여 변수를 선언하면 **선언 단계와 초기화 단계가 동시에 진행된다.**
    - 같은 스코프 내에서 중복 선언이 가능하다.
    - 함수 레벨 스코프
        - 오로지 함수의 코드 블록 만을 지역 스코프를 갖는다.
- **let**
    - let 키워드를 사용하여 변수를 선언하면 **선언 단계와 초기화 단계가 분리되어 진행된다.**
        - 변수 선언문에 도달했을 때 초기화 단계가 실행된다. 즉 호이스팅 되어 선언은 먼저 되지만, 초기화는 되어 있지 않음.
        - 그러므로 변수 선언문에 도달하기 전에 변수를 참조했을 때 에러가 발생한다.
        - 이처럼 스코프의 시작부터 변수 선언문 (초기화 단계)  이전까지 변수를 참조할 수 없는 구간을 일시적 사각지대라고 한다.
    - 중복 선언이 불가능하다 (Syntax Error를 발생시킨다.)
    - 블록 레벨 스코프
        - 함수 블록을 포함한 모든 코드 블록을 지역 스코프로 인정한다.
- **const**
    - const 키워드를 사용하여 변수를 선언할 때에는 반드시 선언과 동시에 초기화해야 한다.
    - **let 과 마찬가지로 호이스팅이 일어나지 않는 것처럼 동작한다.**
    - const로 키워드로 선언한 변수는 재할당이 금지되며 이를 상수라고 표현한다.

### 변수 선언의 실행 시점과 변수 호이스팅

---

- **호이스팅** : 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 JS 고유의 특징 (즉, 코드가 실행되는 시점인 런타임 이전에 실행된다.)
    
    > 변수 선언뿐 아니라 var, let, const, function, function*, class 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, class)는 호이스팅된다.
    
    그렇다면 왜 let과 const는 호이스팅이 발생하지 않은 것 처럼 동작할까?
    이는 자바스크립트 엔진이 변수를 메모리에 선언 단계와 초기화 단계로 분리하여 처리하기 때문이다. 이로 인해 변수가 선언되기 전에 접근하려고 하면 에러가 발생하게 되며, 이는 더욱 예측 가능하고 안전한 코드 작성을 돕는다. (var은 변수가 호이스팅 되기 때문에 어디서든 변수를 참조할 수 있음. 다만 초기화를 먼저 진행하기 때문에 할당문 이전에 참조할 경우 `undefind`)
    > 
    

### 값의 할당

---

<aside>
💡 변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.

</aside>

```tsx
// 예제1

console.log(score); // undefinded

var score = 80;

console.log(score); // 80

```

### 값의 재할당

---

var 키워드로 선언한 변수는 값을 재할당 할 수 있다. 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것이다. 

변수를 변수라고 부르는 이유도 변수에 저장된 값을 변경할 수 있기 때문이다. 만약 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수라 한다.

즉 상수란 한번 정해지면 변하지 않는 값이고, 단 한번만 할당할 수 있는 변수이다.

변수에 값을 재할당하면  새로운 메모리 공간을 확보하고 그 메모리 공간에 새롭게 할당한 값이 저장된다. 그리고 이전의 값은 후에 가비지 콜렉터에 의해 메모리에서 자동 해제 된다. (언제 해제될지는 예측할 수 없다.)

### 식별자 네이밍 규칙

---

일반적으로 변수나 함수의 이름에는 카멜 케이스, **생성자 함수**, 클래스의 이름에는 **파스칼 케이스**를 사용한다.

### var VS let VS const

---

변수 선언에는 기본적으로 const를 사용, let은 재할당이 필요한 경우에 한정해서 사용하는 것이 좋다.

var와 let, const 키워드는 다음과 같이 사용하는 것을 권장한다.

- ES6를 사용한다면 var는 쓰지 않는다.
- 재할당이 필요한 경우에만 let 키워드를 사용한다. 이때 변수의 스코프는 가능한 좁게 만든다.
- 변경이 발생하지 않고 읽기 전용으로 사용하는 원시 값과 객체에는 const를 사용한다.